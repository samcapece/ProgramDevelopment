# team-010-79-hw4

Carlos Chasi-Mejia - chasi009
Samuel Capece - capec016
Jackson Brandt  - bran1281

This project is a real time simulation of a drone delivery service where the user can schedule a package to be picked up by a drone and delivered at any point on a given map. Once the delivery has been scheduled, the user can then watch a 3D visualization of the package being delivered by the drone.

To run the simulation, first you need to go into any sort of terminal and proceed to the directory in which the file was downloaded in. Next the command: ./build/bin/transit_service 8081 apps/transit_service/web/ needs to be run in order to start a server for both the scheduler and the 3D model. After running the command, then go to  http://127.0.0.1:8081 for the 3D model of the delivery map and http://127.0.0.1:8081/schedule.html to schedule deliveries in the 3D model. Once in the scheduler, then give then type in a name for the drone and use the dropdown menu to decide how the drone will create a route to it's destinations. Next, click on two points on the map below to indicate the coordinates of the package and the coordinates of the package's destination. Finally, click on "Schedule Delivery" and switch to the 3D model to watch the drone deliver the package to it's destination. If a different port is used when creating a server for the simulation, then a different URL is used for the 3D model and scheduler. For example, if the port 8082 is used, then http://127.0.0.1:8082 would be used for the 3D model.

When the simulation starts, the 3D model waits for the scheduler to send the coordinates of a delivery route to which it will create a drone entity, a package entity, and a robot entity that represents the end of a drone's route. The drone will then create the shortest route possible using the path finding method specfied by the user first to the package, and then to the robot. Once the drone has found a route, then it will follow that route moving a certain amount of pixels every frame until it is within a few pixels of its package. Then the drone will change the speed, direction, and position of the package to be similar to the drone's to make the package seem like it is being carried. then the drone and package will follow the same route to the robot. Once the drone and the package are a few pixels of the robot, then the drone stays in place and waits until another delivery is scheduled and the package is deleted.

The new features that were added to the simulation were boats that crosses the mississippi river and a notification system telling the user on the progress of the delivery.

The boats in the simulation are created at set points marked by warehouses that drones will deliver to if the package the drone has needs to be delivered to the other side of the river. Once the package has been delivered to the warehouse, then a boat will be created delivering the package to a warehouse directly on the opposite side of the river where the boat is then deleted. The feature is intertesting as this requires the package to be handed between several different entities with different destinations and different speeds while also sending notifications to the user. This adds to the existing work as in a more realistic scenario if there ever needs to be a larger map that requires packages going overseas, then the drones do not need to travel over long distances and potentially run out of batteries. We decided to use the composite factory design pattern for this feature as both the boat and the warehouse would use similar functions as the rest of the entities and inherit the IEntities and IEntitiesFactory class. The feature can not be interacted with by the user beyond scheduling a delivery that would pass over the mississippi river.

The notification system sends the user notifications in the 3D model whenever a package is picked up, dropped off, whenever a drone has recieved a delivery, or if a delivery is late. This feature is interesting as each step of the delivery needed to be considered for the notification system including if the drone needs to pick up or drop off a package from a warehouse or when a drone is going to pick up a package for another delivery. This adds to the existing work as in a more realistic scenario, a user might want to see the progress on a delivery or see if there were any issues with a drone delivering a package. This feature uses the observer design pattern but instead of many objects recieving a notification from a singular object, one object is observing many other objects. This feature does not require any input from the user beyond scheduling a delivery.

For our sprint, it was great at dividing work among all of the group members immediately and providing a list of tasks that could be refered to if one forgot about what needed to be still done for the project. We did not however, consider each person's availability and had trouble refering to the list of tasks on the sprint afterwards. 

Presentation link, goes over our implementation of the notification system as well as the boat and warehouse system: https://youtu.be/sl08jbJqBvc

[Homework 4 extension diagram.pdf](https://github.umn.edu/umn-csci-3081-f23/team-010-79-hw4/files/1057/Homework.4.extension.diagram.pdf)

Dockerfile link, allows for users to run the code after pulling from Docker Hub: https://hub.docker.com/repository/docker/samguy3/project4/general
